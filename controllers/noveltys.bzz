#Init 

MAX = 10.0
MIN = 0.0

PROB = 0.34 #Switching Probability
homophily_threshold = 0.75

function cRand(rid, r){
	r=math.rng.uniform(MIN,MAX)	
	return r
}


function init() {
	count = 0
	r = math.rng.setseed(id)
	i = 0
	vmag = 0.0
	robot_pose = {}
	control_input = {}
	Velocity = {}
	state_vec = {}
	state_vec[0]=0.0
	state_vec[1]=0.0
	state_vec[2]=0.0
	generation = 0
	curr_state = 0.0
	state0 = swarm.create(0)
	state1 = swarm.create(1)
	while( i < 2) {
		robot_pose[i] = 0.0
		Velocity[i] = 0.0
		i = i+1
	}
	# f = io.fopen("exp.dat","w")
}


function step() {
	if(count < 5) {
		count = count +1
	}

	else {
		if(size(control_input) == 0) {
			index = 0
			while(index<8) {
				r = math.rng.uniform(10.0)
				control_input[index] = r
				index = index+1
			}
		}
		else {
			theta = pose.orientation.yaw
			robot_pose[0] = pose.position.x
			robot_pose[1] = pose.position.y

			vl = wheels.velocity.left
			vr = wheels.velocity.right
			l = wheels.axis_length
			# log(vl,"	",vr)
			

			vx = (vl+vr)*(math.cos(theta))/2
			vy = (vl+vr)*(math.sin(theta))/2
			
			Velocity[0] = vx
			Velocity[1] = vy
			# log(velocity[0]," , ",velocity[1])

			# state measurements
			#current state
			state_vec[2] = curr_state
			if(curr_state==1.0)
				set_leds(255,0,0)
			else
				set_leds(0,0,255)
				
			total_kin = neighbors.kin().reduce(function(rid,data,accum){
				if(data.distance<homophily_threshold)
					return accum+1}, 0)
			total_neighbors = neighbors.reduce(function(rid,data,accum){
				if(data.distance<homophily_threshold)
					return accum+1}, 0)
			#homophily
			if(total_neighbors>0)
				state_vec[0] = float(total_kin)/total_neighbors
			else
				state_vec[0] = 0.0

			if(proximity!=nil){
				if(proximity[0].value>0.05){
					if(curr_state==0.0)
						set_wheels(control_input[0],control_input[1])
					else
						set_wheels(control_input[2],control_input[3])
				} else {
					if(curr_state==0.0)
						set_wheels(control_input[4],control_input[5])
					else
						set_wheels(control_input[6],control_input[7])
				}
				if(math.rng.uniform(1.0)<PROB){
					curr_state = 1-curr_state
					#state switching
					state_vec[1] = state_vec[1]+1
				}
			} else {
				log("proximity sensor not initialized")
			}
			state0.leave()
			state1.leave()
			state0.select(curr_state==0)
			state1.select(curr_state==1)
		}
	}
}

function reset() {
}

function destroy() {
	# io.fclose(f)
}
